import numpy as np
import matplotlib.pyplot as plt
from numpy import sqrt, sin, cos, pi
import matplotlib.pyplot as plt
import math
from scipy.integrate import odeint
import matplotlib.ticker as tck
from scipy.interpolate import lagrange
from scipy.integrate import quad




# CREATE A FUNCTION THAT RETURNS THE EXPRESSION OF A GIVEN FUNCTION
import ast
import inspect
def get_return_statement(fct):
    root = ast.parse(inspect.getsource(fct))
    try:
        return_node = next(
            node for node in ast.walk(root) if isinstance(node, ast.Return)
        )
        return ast.unparse(return_node.value)
    except StopIteration:
        return "None"
#print(get_return_statement(f))



#DEFINE THE FUNCTION
def f(x): 
    return sin(1/x**1.5)



#DEFINE THE SECOND DERIVATIVE OF THE FUNCTION
def f_second(x): 
        return 3.75*cos(1/x**1.5)/x**3.5-2.25*sin(1/x**1.5)/x**5


#DEFINE THE INTERVAL ON WHICH WE WANT TO INTEGRATE THE FUNCTION AND THE NUMBER OF COLLOCATION POINTS BETWEEN THE ENDPOINTS
x_0=0.1
x_1=1
number_of_trapez=25 # the number of trapezoids we use for the uniform method     FAIRE AVEC 20 ET 30 TRAPÃˆZES
number_of_points=number_of_trapez+1 # number of points (including endpoints) used for the uniform method
number_of_intervals=10 # number of subdivision of [x_0,x_1] for the refined method
step=(x_1-x_0)/(number_of_intervals)
real_integral=quad(f, x_0, x_1)[0]

f_second_max=[]
epsilon=0
for k in range(0, number_of_intervals):
    x=np.linspace(x_0+k*step+epsilon,x_0+(k+1)*step-epsilon,100)
    f_second_max.append((x[np.argmax(np.abs([f_second(z) for z in x]))],np.max([np.abs([f_second(z) for z in x])])))
#print(f_second_max)

abscisses=[f_second_max[i][0] for i in range(len(f_second_max))]
f_second_max_values=[f_second_max[i][1] for i in range(len(f_second_max))]
#print(f_second_max_values)







# COMPUTE THE NUMBER OF POINTS PER INTERVAL EXCLUDING THE ENDPOINTS OF EACH INTERVAL
weights_per_interval=[np.sqrt(f_second_max_values[i])/(sum(np.sqrt(f_second_max_values))) for i in range(len(f_second_max_values))]
#print(weights_per_interval)
nb_trapez_per_interval=[math.ceil(number_of_trapez*w) for w in weights_per_interval]
#print(nb_trapez_per_interval)
# Then the sum of the number of trapezoids on each subinterval is equal to the number of trapezoids used in the uniform method.

for k in range(len(nb_trapez_per_interval)): # this forces the number of trapezoids in an interval to be at least 1. Tgis happens only if f''=0 on the whole interval.
     if nb_trapez_per_interval[k]==0:
            nb_trapez_per_interval[k]=1

#print(nb_trapez_per_interval)
#print(sum(nb_trapez_per_interval))

while sum(nb_trapez_per_interval) != number_of_trapez: # this forces the total number of trapez to be number_of_trapez by removing/adding points where the max/min is. They might be different at first due to the
     if sum(nb_trapez_per_interval) > number_of_trapez:
          nb_trapez_per_interval[np.argmax(nb_trapez_per_interval)]-=1
     else:
        nb_trapez_per_interval[np.argmin(nb_trapez_per_interval)]+=1

#print(nb_trapez_per_interval)
#print(sum(nb_trapez_per_interval)-number_of_trapez)

# DEFINE THE COLLOCATION POINTS
collocation_list=[]
for k in range(number_of_intervals): 
    if nb_trapez_per_interval[k]>1:
        collocation_list.append(np.linspace(x_0+k*step,x_0+(k+1)*step,nb_trapez_per_interval[k]+1)[1:-1])
        # the [1:-1] is used so that there is no superposition where two intervals meet
#print(collocation_list)

collocation_points=[]
for k in range(len(collocation_list)):
     collocation_points=np.concatenate((collocation_points,collocation_list[k]))

collocation_points=np.sort(np.append(collocation_points, [x_0+k*step for k in range(number_of_intervals+1)])) # add x_0, x_1, and the endpoints of the subintervals 
#print(collocation_points)   
#print(len(collocation_points)-number_of_points)
collocation_values=[f(c) for c in collocation_points] 




# APPROXIMATE THE INTEGRAL OF f USING THE TRAPEZOID METHOD FOR UNIFORM SAMPLING
# Compute the approximation using the trapezoid rule
approx_integral_trapezoid_unif=[]
collocation_points_unif=np.linspace(x_0,x_1,number_of_points)
#print(collocation_points_unif)
#print(len(collocation_points_unif))
collocation_values_unif=[f(c) for c in collocation_points_unif]
for i in range(len(collocation_points_unif)-1):
    if collocation_values_unif[i+1]*collocation_values_unif[i]>=0:
        approx_integral_trapezoid_unif.append((collocation_points_unif[i+1]-collocation_points_unif[i])*(collocation_values_unif[i+1]+collocation_values_unif[i])/2)
    else:
        intersection_unif=collocation_points_unif[i] - collocation_values_unif[i]*(collocation_points_unif[i+1] - collocation_points_unif[i])/(collocation_values_unif[i+1] - collocation_values_unif[i])
        approx_integral_trapezoid_unif.append((intersection_unif-collocation_points_unif[i])*collocation_values_unif[i]/2+(collocation_points_unif[i+1]-intersection_unif)*collocation_values_unif[i+1]/2)
approx_integral_trapezoid_unif=sum(approx_integral_trapezoid_unif)


# Print the result and its difference with the real value
print("The real integral is: {}.".format(real_integral))
print("The integral of the uniform trapezoid polynomial is: {}.".format(approx_integral_trapezoid_unif))
print("The relative error of the uniform trapezoid quadrature is: {} %.".format("%0.4e"%np.abs((real_integral-approx_integral_trapezoid_unif)/real_integral*100)))



# PLOT THE UNIFORM TRAPEZOID APPROXIMATION OF THE FUNCTION f
fig, ax = plt.subplots(figsize=(8, 4), layout=None)
ax.set_xlabel("x",fontsize=50)
ax.set_ylabel("f(x)",fontsize=50)
plt.subplots_adjust(left=0.15,bottom=0.15)
ax.tick_params(axis='both', which='major', labelsize=50)
ax.tick_params(axis='both', which='minor', labelsize=50)
#ax.set_title("Plot of the uniform trapezoid approximation of f(x) with {} intervals \n and {} trapezoids within {}".format(number_of_intervals, number_of_trapez,[x_0,x_1]))
#plt.scatter(collocation_points_unif, [f(c) for c in collocation_points_unif], s=50, marker="^",alpha=0.8)
plt.axhline(y = 0, color = 'k')
for k in range(number_of_intervals):  
     plt.axvline(x = x_0+k*step, color = 'g',linestyle='dashed',linewidth=1)
     plt.axvline(x = x_0+(k+1)*step, color = 'g',linestyle='dashed',linewidth=1)
for i in range(len(collocation_points_unif)-1):
    ax.plot([collocation_points_unif[i],collocation_points_unif[i+1]],[collocation_values_unif[i],collocation_values_unif[i+1]],c='b',linewidth=2.5)
for i in range(len(collocation_points_unif)):
    markerline, stemline, baseline=ax.stem(collocation_points_unif[i], collocation_values_unif[i],'b')
    plt.setp(stemline, linewidth = 1.5)
    plt.setp(markerline, markersize = 4)
plt.plot(np.linspace(x_0,x_1,1000), [f(x) for x in np.linspace(x_0,x_1,1000)],color = 'red',alpha=1,linestyle='dashed',linewidth=2)
#ax.text(x_1-step/2, 2.5, r'Real area$=$'+str(round(real_integral,6)))
#ax.text(x_1-step/2, 2.25, r'Approximated area$=$'+str(round(approx_integral_trapezoid_unif, 6)))
#ax.text(x_1-step/2, 2, r'Relative error (%) to real value$=$'+str(round(np.abs((real_integral-approx_integral_trapezoid_unif)/real_integral*100), 6))+r'$\%$')
plt.show()

 




# APPROXIMATE THE INTEGRAL OF f USING THE REFINED TRAPEZOID METHOD
# Compute the approximation using the trapezoid rule
approx_integral_trapezoid=[]
for i in range(len(collocation_points)-1):
    if collocation_values[i+1]*collocation_values[i] >=0:
        approx_integral_trapezoid.append((collocation_points[i+1]-collocation_points[i])*(collocation_values[i+1]+collocation_values[i])/2)
    else:
        intersection=collocation_points[i] - collocation_values[i]*(collocation_points[i+1] - collocation_points[i])/(collocation_values[i+1] - collocation_values[i])
        approx_integral_trapezoid.append((intersection-collocation_points[i])*collocation_values[i]/2+(collocation_points[i+1]-intersection)*collocation_values[i+1]/2)
approx_integral_trapezoid=sum(approx_integral_trapezoid)


# Print the result and its difference with the real value
print("The real integral is: {}.".format(real_integral))
print("The integral of the refined trapezoid polynomial is: {}.".format(approx_integral_trapezoid))
print("The relative error (%) of the refined trapezoid quadrature is: {} %.".format("%0.4e"%np.abs((real_integral-approx_integral_trapezoid)/real_integral*100)))




# PLOT THE REFINED TRAPEZOID APPROXIMATION OF THE FUNCTION f
fig, ax = plt.subplots(figsize=(8, 4), layout=None)
ax.set_xlabel("x",fontsize=50)
ax.set_yticks([])
ax.tick_params(axis='both', which='major', labelsize=50)
plt.subplots_adjust(left=0.15,bottom=0.15)
#ax.set_ylabel("f(x)")
#ax.set_title("Plot of the refined trapezoid approximation of f(x) with {} intervals \n and {} trapezoids within {}".format(number_of_intervals, number_of_trapez,[x_0,x_1]))
#plt.scatter(collocation_points, [f(c) for c in collocation_points], s=50, marker="^",alpha=0.8)
plt.axhline(y = 0, color = 'k')
for k in range(number_of_intervals):  
     plt.axvline(x = x_0+k*step, color = 'g',linestyle='dashed',linewidth=1)
     plt.axvline(x = x_0+(k+1)*step, color = 'g',linestyle='dashed',linewidth=1)
for i in range(len(collocation_points)-1):
    ax.plot([collocation_points[i],collocation_points[i+1]],[collocation_values[i],collocation_values[i+1]],c='b',linewidth=2.5)
for i in range(len(collocation_points)):
    markerline, stemline, baseline=ax.stem(collocation_points[i], collocation_values[i],'b')
    plt.setp(stemline, linewidth = 1.5)
    plt.setp(markerline, markersize = 4)
plt.plot(np.linspace(x_0,x_1,1000), [f(x) for x in np.linspace(x_0,x_1,1000)],color='red',alpha=1,linestyle='dashed',linewidth=2)
#ax.text(x_1-step/2, 2.5, r'Real area$=$'+str(round(real_integral,6)))
#ax.text(x_1-step/2, 2.25, r'Approximated area$=$'+str(round(approx_integral_trapezoid, 6)))
#ax.text(x_1-step/2, 2, r'Relative error (%) to real value$=$'+str(round(np.abs((real_integral-approx_integral_trapezoid)/real_integral*100), 6))+r'$\%$')
plt.show() 
